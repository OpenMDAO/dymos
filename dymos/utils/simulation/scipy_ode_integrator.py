from __future__ import print_function, division, absolute_import

import sys
from collections import OrderedDict

import numpy as np
from dymos.utils.simulation.components.control_interpolation_comp import ControlInterpolationComp
from dymos.utils.simulation.components.state_rate_collector_comp import StateRateCollectorComp
from dymos.utils.simulation.progress_bar_observer import ProgressBarObserver
from dymos.utils.simulation.simulation_results import SimulationResults
from dymos.utils.simulation.std_out_observer import StdOutObserver
from openmdao.core.analysis_error import AnalysisError
from openmdao.core.group import Group
from openmdao.core.indepvarcomp import IndepVarComp
from openmdao.core.problem import Problem
from scipy.integrate import ode
from six import iteritems


class ScipyODEIntegrator(object):
    """
    Given a system class, create a callable object with the same signature as that required
    by scipy.integrate.ode::

        f(t, x, *args)

    Internally, this is accomplished by constructing an OpenMDAO problem using the ODE with
    a single node.  The interface populates the values of the time, states, and controls,
    and then calls `run_model()` on the problem.  The state rates generated by the ODE
    are then returned back to scipy ode, which continues the integration.

    Parameters
    ----------
    ode_class : OpenMDAO system with ode_options attribute
        The ODE system to be numerically integrated.

    """
    def __init__(self, ode_class, time_options, state_options, control_options,
                 design_parameter_options, ode_init_kwargs=None):
        self.prob = Problem(model=Group())

        self.ode = ode

        # The ODE System
        self.prob.model.add_subsystem('ode', subsys=ode_class(num_nodes=1, **ode_init_kwargs))
        self.ode_options = ode_class.ode_options

        # Get the state vector.  This isn't necessarily ordered
        # so just pick the default ordering and go with it.
        self.state_options = OrderedDict()
        self.time_options = time_options
        self.control_options = control_options
        self.design_parameter_options = design_parameter_options

        pos = 0

        for state, options in iteritems(state_options):
            self.state_options[state] = {'rate_source': options['rate_source'],
                                         'pos': pos,
                                         'shape': options['shape'],
                                         'size': np.prod(options['shape']),
                                         'units': options['units'],
                                         'targets': options['targets']}
            pos += self.state_options[state]['size']

        self._state_vec = np.zeros(pos, dtype=float)
        self._state_rate_vec = np.zeros(pos, dtype=float)

        # The Time Comp
        self.prob.model.add_subsystem('time_input',
                                      IndepVarComp('time',
                                                   val=0.0,
                                                   units=self.ode_options._time_options['units']),
                                      promotes_outputs=['time'])

        if self.ode_options._time_options['targets'] is not None:
            self.prob.model.connect('time',
                                    ['ode.{0}'.format(tgt) for tgt in
                                     self.ode_options._time_options['targets']])

        # The States Comp
        indep = IndepVarComp()
        for name, options in iteritems(self.state_options):
            indep.add_output('states:{0}'.format(name),
                             shape=(1, np.prod(options['shape'])),
                             units=options['units'])
            if options['targets'] is not None:
                self.prob.model.connect('states:{0}'.format(name),
                                        ['ode.{0}'.format(tgt) for tgt in options['targets']])
            self.prob.model.connect('ode.{0}'.format(options['rate_source']),
                                    'state_rate_collector.state_rates_in:{0}_rate'.format(name))

        self.prob.model.add_subsystem('indep_states', subsys=indep,
                                      promotes_outputs=['*'])

        # The Control interpolation comp
        time_units = self.ode_options._time_options['units']
        self._interp_comp = ControlInterpolationComp(time_units=time_units,
                                                     control_options=control_options)

        # The state rate collector comp
        self.prob.model.add_subsystem('state_rate_collector',
                                      StateRateCollectorComp(state_options=self.state_options,
                                                             time_units=time_options['units']))

        # Flag that is set to true if has_controls is called
        self._has_dynamic_controls = False

    def setup(self, check=False, mode='fwd'):
        """
        Call setup on the ScipyODEIntegrator's problem instance.

        Parameters
        ----------
        check : bool
            If True, run setup on the problem instance with checks enabled.
            Default is False.

        """
        model = self.prob.model

        order = ['time_input', 'indep_states']

        if self.control_options:
            model.add_subsystem('indep_controls', self._interp_comp, promotes_outputs=['*'])

            order += ['indep_controls']
            model.connect('time', ['indep_controls.time'])

            for name, options in iteritems(self.control_options):
                if name in self.ode_options._parameters:
                    targets = self.ode_options._parameters[name]['targets']
                    model.connect('controls:{0}'.format(name),
                                  ['ode.{0}'.format(tgt) for tgt in targets])
                if options['rate_param']:
                    rate_param = options['rate_param']
                    rate_targets = self.ode_options._parameters[rate_param]['targets']
                    model.connect('control_rates:{0}_rate'.format(name),
                                  ['ode.{0}'.format(tgt) for tgt in rate_targets])
                if options['rate2_param']:
                    rate2_param = options['rate2_param']
                    rate2_targets = self.ode_options._parameters[rate2_param]['targets']
                    model.connect('control_rates:{0}_rate2'.format(name),
                                  ['ode.{0}'.format(tgt) for tgt in rate2_targets])

        if self.design_parameter_options:
            ivc = model.add_subsystem('indep_design_params', IndepVarComp(), promotes_outputs=['*'])

            order += ['indep_design_params']

            for name, options in iteritems(self.design_parameter_options):
                ivc.add_output('design_parameters:{0}'.format(name), val=np.zeros(options['shape']),
                               units=options['units'])
                if name in self.ode_options._parameters:
                    targets = self.ode_options._parameters[name]['targets']
                    model.connect('design_parameters:{0}'.format(name),
                                  ['ode.{0}'.format(tgt) for tgt in targets])

        order += ['ode', 'state_rate_collector']
        model.set_order(order)

        self.prob.setup(check=check, mode=mode)

    def set_interpolant(self, name, interpolant):
        """
        Set the interpolator to be used for the control of the given name.

        Parameters
        ----------
        name : str
            The name of the control whose interpolant is being specified.
        interpolant : object
            An object that provides interpolation for the control as a function of time.
            The object must have methods `eval(t)` which returns the interpolated value
            of the control at time t, and `eval_deriv(t)` which returns the interpolated
            value of the first time-derivative of the control at time t.
        """
        self._interp_comp.interpolants[name] = interpolant

    def set_design_param_value(self, name, val, units=None):
        """
        Sets the values of design parameters in the problem, once self.prob has been setup.

        Parameters
        ----------
        name : str
            The name of the design parameter whose value is being set
        val : float or ndarray
            The value of the design parameter
        units : str or None
            The units in which the design parameter value is set.

        """
        self.prob.set_val('design_parameters:{0}'.format(name), val, units)

    def _unpack_state_vec(self, x):
        """
        Given the state vector in 1D, extract the values corresponding to
        each state into the ode integrators problem states.

        Parameters
        ----------
        x : np.array
            The 1D state vector.

        Returns
        -------
        None

        """
        for state_name, state_options in self.state_options.items():
            pos = state_options['pos']
            size = state_options['size']
            self.prob['states:{0}'.format(state_name)][0, ...] = x[pos:pos + size]

    def _pack_state_rate_vec(self):
        """
        Pack the state rates into a 1D vector for use by scipy odeint.

        Returns
        -------
        dXdt: np.array
            The 1D state-rate vector.

        """
        for state_name, state_options in self.state_options.items():
            pos = state_options['pos']
            size = state_options['size']
            self._state_rate_vec[pos:pos + size] = \
                np.ravel(self.prob['state_rate_collector.'
                                   'state_rates:{0}_rate'.format(state_name)])
        return self._state_rate_vec

    def _pack_state_vec(self, x_dict):
        """
        Pack the state into a 1D vector for use by scipy.integrate.ode.

        Returns
        -------
        x: np.array
            The 1D state vector.

        """
        self._state_vec[:] = 0.0
        for state_name, state_options in self.state_options.items():
            pos = state_options['pos']
            size = state_options['size']
            self._state_vec[pos:pos + size] = np.ravel(x_dict[state_name])
        return self._state_vec

    def _f_ode(self, t, x, *args):
        """
        The function interface used by scipy.ode

        Parameters
        ----------
        t : float
            The current time, t.
        x : np.array
            The 1D state vector.

        Returns
        -------
        xdot : np.array
            The 1D vector of state time-derivatives.

        """
        self.prob['time'] = t
        self._unpack_state_vec(x)
        self.prob.run_model()
        xdot = self._pack_state_rate_vec()
        return xdot

    def integrate_times(self, x0_dict, times,
                        integrator='vode', integrator_params=None,
                        observer=None):
        """
        Integrate the RHS with the given initial state, and record the values at the
        specified times.

        Parameters
        ----------
        x0_dict : dict
            A dictionary keyed by state variable name that contains the
            initial values for the states.  If absent the initial value is
            assumed to be zero.
        times : sequence
            The sequence of times at which output for the integration is desired.
        integrator : str
            The integrator to be used by scipy.ode.  This is one of:
            vode, zvode, lsoda, dopri5, or dopri853.
        integrator_params : dict
            Parameters specific to the chosen integrator.  See the Scipy
            documentation for details.
        observer : callable, str, or None
            A callable function to be called at the specified timesteps in
            `integrate_times`.  This can be used to record the integrated trajectory.
            If 'default', a StdOutObserver will be used, which outputs all variables
            in the model to standard output by default.
            If None, no observer will be called.

        Returns
        -------
        dict
            A dictionary of variables in the RHS and their values at the given times.

        """

        # Prepare the observer
        if observer == 'stdout':
            _observer = StdOutObserver(self)
        elif observer == 'progress-bar':
            _observer = ProgressBarObserver(self, out_stream=sys.stdout, t0=times[0], tf=times[-1])
        else:
            _observer = observer

        int_params = integrator_params if integrator_params else {}

        solver = ode(self._f_ode)

        x0 = self._pack_state_vec(x0_dict)

        solver.set_integrator(integrator, **int_params)
        solver.set_initial_value(x0, times[0])

        delta_times = np.diff(times)

        # Run the Model once to get the initial values of all variables
        self._f_ode(solver.t, solver.y)

        # Prepare the output dictionary
        results = SimulationResults(time_options=self.time_options,
                                    state_options=self.state_options,
                                    control_options=self.control_options)

        model_outputs = self.prob.model.list_outputs(units=True, shape=True, out_stream=None)

        for output_name, options in model_outputs:
            prom_name = self.prob.model._var_abs2prom['output'][output_name]
            results.outputs[prom_name] = {}
            results.outputs[prom_name]['value'] = np.atleast_2d(self.prob[prom_name]).copy()
            results.outputs[prom_name]['units'] = options['units']

        if _observer:
            _observer(solver.t, solver.y, self.prob)

        terminate = False
        for dt in delta_times:

            try:
                solver.integrate(solver.t + dt)
                self._f_ode(solver.t, solver.y)
            except AnalysisError:
                terminate = True

            for var in results.outputs:
                results.outputs[var]['value'] = np.concatenate((results.outputs[var]['value'],
                                                                np.atleast_2d(self.prob[var])),
                                                               axis=0)
            if _observer:
                _observer(solver.t, solver.y, self.prob)

            if terminate:
                break

        return results
