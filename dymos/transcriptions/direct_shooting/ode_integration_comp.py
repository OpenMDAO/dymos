import numpy as np
import openmdao.api as om
from scipy.integrate import solve_ivp

from ...options import options as dymos_options

from .ode_evaluation_group import ODEEvaluationGroup
from ...utils.misc import get_rate_units
from ...utils.introspection import filter_outputs, get_promoted_vars


class ODEIntegrationComp(om.ExplicitComponent):
    """
    A component to perform explicit integration with a generic ODE integrator/IVP solver.

    This component contains a sub-Problem with a component that will be solved over num_nodes
    points instead of creating num_nodes instances of that same component and connecting them
    together.

    Parameters
    ----------
    ode_class : class
        The class of the OpenMDAO system to be used to evaluate the ODE in this Group.
    time_options : OptionsDictionary
        OptionsDictionary of time options.
    state_options : dict of {str: OptionsDictionary}
        For each state variable, a dictionary of its options, keyed by name.
    parameter_options : dict of {str: OptionsDictionary}
        For each parameter, a dictionary of its options, keyed by name.
    control_options : dict of {str: OptionsDictionary}
        For each control variable, a dictionary of its options, keyed by name.
    polynomial_control_options : dict of {str: OptionsDictionary}
        For each polynomial variable, a dictionary of its options, keyed by name.
    timeseries_options : dict
        The timeseries options associated with the parent phase. This is used to access
        requested timeseries outputs.  Some options regarding timeseries are not applicable
        to the RungeKutta integration.
    grid_data : GridData
        The GridData instance pertaining to the phase to which this ODEEvaluationGroup belongs.
    standalone_mode : bool
        When True, this component will perform its configuration during setup. This is useful
        for unittesting this component when not embedded in a larger system.
    reports : bool or None or str or Sequence
        Controls the reports generated by the subproblems used during the integration.
    **kwargs : dict
        Additional keyword arguments passed to Group.

    Notes
    -----
    This code includes the following unicode symbols:
    theta:  U+03B8
    """
    def __init__(self, ode_class, time_options=None,
                 state_options=None, parameter_options=None, control_options=None,
                 polynomial_control_options=None, timeseries_options=None,
                 grid_data=None, standalone_mode=True, reports=False, **kwargs):
        super().__init__(**kwargs)
        self.ode_class = ode_class
        self.time_options = time_options
        self.state_options = state_options
        self.parameter_options = parameter_options or {}
        self.control_options = control_options or {}
        self.polynomial_control_options = polynomial_control_options or {}
        self.timeseries_options = timeseries_options or {}
        self._eval_subprob = None
        self._grid_data = grid_data
        self._DTYPE = float
        self._reports = reports

        self._inputs_cache = None

        self.x_size = 0
        self.p_size = 0
        self.u_size = 0
        self.up_size = 0
        self.theta_size = 0
        self.Z_size = 0

        self._state_rate_of_names = []
        self._totals_of_names = []
        self._totals_wrt_names = []

        # If _standalone_mode is True, this component will fully perform all of its setup at setup
        # time.  If False, it will need to have configure_io called on it to properly finish its
        # setup.
        self._standalone_mode = standalone_mode
        self._no_check_partials = not dymos_options['include_check_partials']
        self._num_control_input_nodes = grid_data.subset_num_nodes['control_input']

    def initialize(self):
        """
        Declare options for the ODEIntegrationComp.
        """
        self.options.declare('integrator', default=solve_ivp,
                             desc='The function which performs the integration, assumed to have the same signature'
                                  ' as scipy.integrate.solve_ivp (the default).', recordable=False)
        self.options.declare('method', default='DOP853', desc='The integration method used.')
        self.options.declare('atol', types=float, default=1.0E-2)
        self.options.declare('rtol', types=float, default=1.0E-4)
        self.options.declare('first_step', types=float, allow_none=True, default=None)
        self.options.declare('max_step', types=float, default=np.inf)
        self.options.declare('times_per_seg', types=(int,), allow_none=True, default=None,
                             desc='The number of output times per segment. If specified, they are evenly spaced. If '
                                  'not specified, output at all nodes in the segment as given by the transcription.')

        self.options.declare('ode_init_kwargs', types=dict, allow_none=True, default=None)

    def _setup_subprob(self):
        self._eval_subprob = p = om.Problem(comm=self.comm, reports=self._reports)
        p.model.add_subsystem('ode_eval',
                              ODEEvaluationGroup(self.ode_class, self.time_options,
                                                 self.state_options,
                                                 self.parameter_options,
                                                 self.control_options,
                                                 self.polynomial_control_options,
                                                 ode_init_kwargs=self.options['ode_init_kwargs'],
                                                 grid_data=self._grid_data),
                              promotes_inputs=['*'],
                              promotes_outputs=['*'])

        p.setup()
        p.final_setup()

    def _set_segment_index(self, idx):
        """
        Set the index of the segment being integrated.
        """
        self._eval_subprob.model._get_subsystem('ode_eval').set_segment_index(idx)


    def _allocate_storage(self):
        N = self.options['times_per_seg']
        num_rows = self._num_rows
        num_x = self.x_size
        num_theta = self.theta_size
        num_z = num_x + num_theta
        num_y = self.y_size

        # # The contiguous vector of state values
        # self._x = np.zeros((num_rows, self.x_size, 1), dtype=self._DTYPE)
        #
        # # The contiguous vector of time values
        # self._t = np.zeros((num_rows, 1), dtype=self._DTYPE)
        #
        # # The contiguous vector of ODE parameter values
        # self._theta = np.zeros((self.theta_size, 1), dtype=self._DTYPE)
        #
        # # The contiguous vector of state rates
        # self._f = np.zeros((self.x_size, 1), dtype=self._DTYPE)
        #
        # # The contiguous vector of ODE algebraic outputs
        # self._y = np.zeros((num_rows, num_y, 1), dtype=self._DTYPE)

        # # The derivatives of the state rates wrt the current time
        # self._f_t = np.zeros((self.x_size, 1), dtype=self._DTYPE)
        # self._f_t_vec = np.zeros((num_stages, self.x_size, 1), dtype=self._DTYPE)
        #
        # # The derivatives of the state rates wrt the current state
        # self._f_x = np.zeros((self.x_size, self.x_size), dtype=self._DTYPE)
        # self._f_x_vec = np.zeros((num_stages, self.x_size, self.x_size), dtype=self._DTYPE)
        #
        # # The derivatives of the state rates wrt the parameters
        # self._f_theta = np.zeros((self.x_size, self.theta_size), dtype=self._DTYPE)
        # self._f_theta_vec = np.zeros((num_stages, self.x_size, self.theta_size), dtype=self._DTYPE)
        #
        # # The derivatives of the state rates wrt the current time
        # self._y_t = np.zeros((self.y_size, 1), dtype=self._DTYPE)
        # self._y_t_vec = np.zeros((num_stages, self.y_size, 1), dtype=self._DTYPE)
        #
        # # The derivatives of the state rates wrt the current state
        # self._y_x = np.zeros((self.y_size, self.x_size), dtype=self._DTYPE)
        # self._y_x_vec = np.zeros((num_stages, self.y_size, self.x_size), dtype=self._DTYPE)
        #
        # # The derivatives of the state rates wrt the parameters
        # self._y_theta = np.zeros((self.y_size, self.theta_size), dtype=self._DTYPE)
        # self._y_theta_vec = np.zeros((num_stages, self.y_size, self.theta_size), dtype=self._DTYPE)
        #
        # # Intermediate state rate storage
        # self._k_q = np.zeros((num_stages, self.x_size, 1), dtype=self._DTYPE)
        #
        # # Intermediate time and states
        # self._T_i = np.zeros((num_stages, 1), dtype=self._DTYPE)
        # self._X_i = np.zeros((num_stages, self.x_size, 1), dtype=self._DTYPE)
        #
        # # The partial derivative of the final state vector wrt time from state update equation.
        # self.px_pt = np.zeros((self.x_size, 1), dtype=self._DTYPE)
        #
        # # The partial derivative of the final state vector wrt the initial state vector from the
        # # state update equation.
        # self.px_px = np.zeros((self.x_size, self.x_size), dtype=self._DTYPE)
        #
        # # Derivatives pertaining to the stage ODE evaluations
        # self._dTi_dZ = np.zeros((1, num_z), dtype=self._DTYPE)
        # self._dXi_dZ = np.zeros((num_x, num_z), dtype=self._DTYPE)
        # self._dkq_dZ = np.zeros((num_stages, num_x, num_z), dtype=self._DTYPE)
        #
        # # The ODE parameter derivatives wrt the integration parameters
        # self._dtheta_dZ = np.zeros((num_theta, num_z), dtype=self._DTYPE)
        # self._dtheta_dZ[:, num_x:] = np.eye(num_theta, dtype=self._DTYPE)
        #
        # # Total derivatives of evolving quantities (x, t, h) wrt the integration parameters.
        # # Let Z be [x0.ravel() t0 tp p.ravel() u.ravel()]
        # self._dx_dZ = np.zeros((num_rows, num_x, num_z), dtype=self._DTYPE)
        # self._dx_dZ[:, :, :num_x] = np.eye(num_x, dtype=self._DTYPE)
        # self._dt_dZ = np.zeros((num_rows, 1, num_z), dtype=self._DTYPE)
        # self._dt_dZ[:, 0, num_x] = 1.0
        # self._dh_dZ = np.zeros((num_rows, 1, num_z), dtype=self._DTYPE)
        # self._dh_dZ[:, 0, num_x+1] = 1.0 / N
        #
        # # Total derivatives of ODE outputs (y) wrt the integration parameters.
        # self._dy_dZ = np.zeros((num_rows, num_y, num_z), dtype=self._DTYPE)

    def _setup_time(self):
        if self._standalone_mode:
            self._configure_time_io()

    def _configure_time_io(self):
        num_output_rows = self._num_output_rows

        self._totals_of_names.append('t')
        self._totals_wrt_names.extend(['t', 't_initial', 't_duration'])

        self.add_input('t_initial', shape=(1,), units=self.time_options['units'])
        self.add_input('t_duration', shape=(1,), units=self.time_options['units'])
        self.add_output('t_final', shape=(1,), units=self.time_options['units'])
        self.add_output('t', shape=(num_output_rows, 1), units=self.time_options['units'])
        self.add_output('t_phase', shape=(num_output_rows, 1), units=self.time_options['units'])

        self.declare_partials('t_final', 't_initial', val=1.0)
        self.declare_partials('t_final', 't_duration', val=1.0)
        self.declare_partials('t', 't_initial', val=1.0)
        self.declare_partials('t', 't_duration', val=1.0)
        self.declare_partials('t_phase', 't_duration', val=1.0)

    def _setup_states(self):
        if self._standalone_mode:
            self._configure_states_io()

    def _configure_states_io(self):
        num_output_rows = self._num_output_rows

        # The total size of the entire state vector
        self.x_size = 0

        self._state_input_names = {}
        self._state_output_names = {}

        # The indices of each state in x
        self.state_idxs = {}

        # The indices of each state's initial value in Z
        self._state_idxs_in_Z = {}

        for state_name, options in self.state_options.items():
            self._state_input_names[state_name] = f'states:{state_name}'
            self._state_output_names[state_name] = f'states_out:{state_name}'

            # Keep track of the derivative "of" names for state rates separately, so we don't
            # request them when they're not necessary.
            self._state_rate_of_names.append(f'state_rate_collector.state_rates:{state_name}_rate')
            self._totals_wrt_names.append(self._state_input_names[state_name])

            self.add_input(self._state_input_names[state_name],
                           shape=options['shape'],
                           units=options['units'],
                           desc=f'initial value of state {state_name}')
            self.add_output(self._state_output_names[state_name],
                            shape=(num_output_rows,) + options['shape'],
                            units=options['units'],
                            desc=f'final value of state {state_name}')

            state_size = np.prod(options['shape'], dtype=int)

            # The indices of the state in x
            self.state_idxs[state_name] = np.s_[self.x_size:self.x_size + state_size]
            self.x_size += state_size

            self.declare_partials(of=self._state_output_names[state_name],
                                  wrt='t_initial')

            self.declare_partials(of=self._state_output_names[state_name],
                                  wrt='t_duration')

            for state_name_wrt in self.state_options:
                self.declare_partials(of=self._state_output_names[state_name],
                                      wrt=f'states:{state_name_wrt}')

            for param_name_wrt in self.parameter_options:
                self.declare_partials(of=self._state_output_names[state_name],
                                      wrt=f'parameters:{param_name_wrt}')

            for control_name_wrt in self.control_options:
                self.declare_partials(of=self._state_output_names[state_name],
                                      wrt=f'controls:{control_name_wrt}')

            for control_name_wrt in self.polynomial_control_options:
                self.declare_partials(of=self._state_output_names[state_name],
                                      wrt=f'polynomial_controls:{control_name_wrt}')

    def _setup_parameters(self):
        if self._standalone_mode:
            self._configure_parameters_io()

    def _configure_parameters_io(self):
        # The indices of each parameter in p
        self.p_size = 0
        self.parameter_idxs = {}
        self._parameter_idxs_in_theta = {}
        self._parameter_idxs_in_Z = {}
        self._param_input_names = {}

        for param_name, options in self.parameter_options.items():
            self._param_input_names[param_name] = f'parameters:{param_name}'
            self._totals_wrt_names.append(self._param_input_names[param_name])

            self.add_input(self._param_input_names[param_name],
                           shape=options['shape'],
                           val=options['val'],
                           units=options['units'],
                           desc=f'value for parameter {param_name}')

            param_size = np.prod(options['shape'], dtype=int)
            self.parameter_idxs[param_name] = np.s_[self.p_size:self.p_size+param_size]
            self.p_size += param_size

    def _setup_controls(self):
        if self._standalone_mode:
            self._configure_controls_io()

    def _configure_controls_io(self):
        self.u_size = 0
        self.control_idxs = {}
        self._control_idxs_in_theta = {}
        self._control_idxs_in_Z = {}
        self._control_idxs_in_y = {}
        self._control_rate_idxs_in_y = {}
        self._control_rate2_idxs_in_y = {}
        self._control_input_names = {}
        self._control_output_names = {}
        self._control_rate_names = {}
        self._control_rate2_names = {}

        num_output_rows = self._num_output_rows

        if self.control_options:
            time_units = self.time_options['units']

        for control_name, options in self.control_options.items():
            control_param_shape = (self._num_control_input_nodes,) + options['shape']
            control_param_size = np.prod(control_param_shape, dtype=int)
            self._control_input_names[control_name] = f'controls:{control_name}'
            self._control_output_names[control_name] = f'control_values:{control_name}'
            self._control_rate_names[control_name] = f'control_rates:{control_name}_rate'
            self._control_rate2_names[control_name] = f'control_rates:{control_name}_rate2'

            self._totals_wrt_names.append(self._control_input_names[control_name])
            self._totals_of_names.append(self._control_output_names[control_name])
            self._totals_of_names.append(self._control_rate_names[control_name])
            self._totals_of_names.append(self._control_rate2_names[control_name])

            self.add_input(self._control_input_names[control_name],
                           shape=control_param_shape,
                           units=options['units'],
                           desc=f'values for control {control_name} at input nodes')

            self.add_output(self._control_output_names[control_name],
                            shape=(num_output_rows,) + options['shape'],
                            units=options['units'],
                            desc=f'values for control {control_name} at output nodes')

            self.add_output(self._control_rate_names[control_name],
                            shape=(num_output_rows,) + options['shape'],
                            units=get_rate_units(options['units'], time_units, deriv=1),
                            desc=f'values for rate of control {control_name} at output nodes')

            self.add_output(self._control_rate2_names[control_name],
                            shape=(num_output_rows,) + options['shape'],
                            units=get_rate_units(options['units'], time_units, deriv=2),
                            desc=f'values for second derivative rate of control {control_name} at output nodes')

            self.declare_partials(of=self._control_output_names[control_name],
                                  wrt=self._control_input_names[control_name],
                                  val=1.0)

            self.declare_partials(of=self._control_rate_names[control_name],
                                  wrt=self._control_input_names[control_name],
                                  val=1.0)

            self.declare_partials(of=self._control_rate2_names[control_name],
                                  wrt=self._control_input_names[control_name],
                                  val=1.0)

            self.declare_partials(of=self._control_rate_names[control_name],
                                  wrt='t_duration',
                                  val=1.0)

            self.declare_partials(of=self._control_rate2_names[control_name],
                                  wrt='t_duration',
                                  val=1.0)

            self.control_idxs[control_name] = np.s_[self.u_size:self.u_size+control_param_size]
            self.u_size += control_param_size

    def _configure_polynomial_controls_io(self):
        self.up_size = 0
        self.polynomial_control_idxs = {}
        self._polynomial_control_idxs_in_theta = {}
        self._polynomial_control_idxs_in_Z = {}
        self._polynomial_control_input_names = {}
        self._polynomial_control_output_names = {}
        self._polynomial_control_rate_names = {}
        self._polynomial_control_rate2_names = {}
        self._polynomial_control_idxs_in_y = {}
        self._polynomial_control_rate_idxs_in_y = {}
        self._polynomial_control_rate2_idxs_in_y = {}

        num_output_rows = self._num_output_rows
        time_units = self.time_options['units']

        for name, options in self.polynomial_control_options.items():
            num_input_nodes = options['order'] + 1
            control_param_shape = (num_input_nodes,) + options['shape']
            control_param_size = np.prod(control_param_shape, dtype=int)

            self._polynomial_control_input_names[name] = f'polynomial_controls:{name}'
            self._polynomial_control_output_names[name] = f'polynomial_control_values:{name}'
            self._polynomial_control_rate_names[name] = f'polynomial_control_rates:{name}_rate'
            self._polynomial_control_rate2_names[name] = f'polynomial_control_rates:{name}_rate2'

            self._totals_wrt_names.append(self._polynomial_control_input_names[name])
            self._totals_of_names.append(self._polynomial_control_output_names[name])
            self._totals_of_names.append(self._polynomial_control_rate_names[name])
            self._totals_of_names.append(self._polynomial_control_rate2_names[name])

            self.add_input(self._polynomial_control_input_names[name],
                           shape=control_param_shape,
                           units=options['units'],
                           desc=f'values for control {name} at input nodes')

            self.add_output(self._polynomial_control_output_names[name],
                            shape=(num_output_rows,) + options['shape'],
                            units=options['units'],
                            desc=f'values for control {name} at output nodes')

            self.add_output(self._polynomial_control_rate_names[name],
                            shape=(num_output_rows,) + options['shape'],
                            units=get_rate_units(options['units'], time_units, deriv=1),
                            desc=f'values for rate of control {name} at output nodes')

            self.add_output(self._polynomial_control_rate2_names[name],
                            shape=(num_output_rows,) + options['shape'],
                            units=get_rate_units(options['units'], time_units, deriv=2),
                            desc=f'values for second derivative rate of control {name} at output nodes')

            self.declare_partials(of=self._polynomial_control_output_names[name],
                                  wrt=self._polynomial_control_input_names[name],
                                  val=1.0)

            self.declare_partials(of=self._polynomial_control_rate_names[name],
                                  wrt=self._polynomial_control_input_names[name],
                                  val=1.0)

            self.declare_partials(of=self._polynomial_control_rate2_names[name],
                                  wrt=self._polynomial_control_input_names[name],
                                  val=1.0)

            self.declare_partials(of=self._polynomial_control_rate_names[name],
                                  wrt='t_duration',
                                  val=1.0)

            self.declare_partials(of=self._polynomial_control_rate2_names[name],
                                  wrt='t_duration',
                                  val=1.0)

            self.polynomial_control_idxs[name] = np.s_[self.up_size:self.up_size+control_param_size]
            self.up_size += control_param_size

    def _setup_timeseries(self):
        if self._standalone_mode:
            self._configure_timeseries_outputs()

    def _configure_timeseries_outputs(self):
        """
        Creates a mapping of {output_name : {'path': str, 'units': str, 'shape': tuple, 'idxs_in_y': numpy.Indexer}.

        This mapping is used to determine which variables of the ODE need to be saved in the
        algebratic outputs (y) due to being requested as timeseries outputs.
        """
        num_output_rows = self._num_output_rows
        ode_eval = self._eval_subprob.model._get_subsystem('ode_eval.ode')
        ode_outputs = get_promoted_vars(ode_eval, 'output')

        self._timeseries_output_names = {}
        self._timeseries_idxs_in_y = {}
        self._filtered_timeseries_outputs = {}

        for ts_opts in self.timeseries_options.values():
            patterns = [output['name'] for output in ts_opts['outputs'].values()]
            matching_outputs = filter_outputs(patterns, ode_outputs)

            explicit_requests = {var for var in patterns if '*' not in var}

            for var, var_meta in matching_outputs.items():
                if var in explicit_requests:
                    ts_output = next((output for output in ts_opts['outputs'].values() if output['name'] == var))
                    # var explicitly matched
                    output_name = ts_output['output_name'] if ts_output['output_name'] else ts_output['name'].rpartition('.')[-1]
                    units = ts_output['units'] or var_meta.get('units', None)
                    shape = var_meta['shape']
                else:
                    # var matched via wildcard
                    output_name = var.rpartition('.')[-1]
                    units = var_meta['units']
                    shape = var_meta['shape']

                if output_name in self._filtered_timeseries_outputs:
                    raise ValueError(f"Requested timeseries output {var} matches multiple output names "
                                     f"within the ODE. Use `<phase>.add_timeseries_output({var}, "
                                     f"output_name=<new_name>)' to disambiguate the timeseries name.")

                self._filtered_timeseries_outputs[output_name] = {'path': f'ode_eval.ode.{var}',
                                                                  'units': units,
                                                                  'shape': shape}

                ode_eval.add_constraint(var)

                self._timeseries_output_names[output_name] = f'timeseries:{output_name}'
                self._totals_of_names.append(self._filtered_timeseries_outputs[output_name]['path'])

                self.add_output(self._timeseries_output_names[output_name],
                                shape=(num_output_rows,) + shape,
                                units=units,
                                desc=f'values for timeseries output {output_name} at output nodes')

                self.declare_partials(of=self._timeseries_output_names[output_name],
                                      wrt='t_initial')

                self.declare_partials(of=self._timeseries_output_names[output_name],
                                      wrt='t_duration')

                for state_name_wrt in self.state_options:
                    self.declare_partials(of=self._timeseries_output_names[output_name],
                                          wrt=self._state_input_names[state_name_wrt])

                for param_name_wrt in self.parameter_options:
                    self.declare_partials(of=self._timeseries_output_names[output_name],
                                          wrt=self._param_input_names[param_name_wrt])

                for control_name_wrt in self.control_options:
                    self.declare_partials(of=self._timeseries_output_names[output_name],
                                          wrt=self._control_input_names[control_name_wrt])

                for control_name_wrt in self.polynomial_control_options:
                    self.declare_partials(of=self._timeseries_output_names[output_name],
                                          wrt=self._polynomial_control_input_names[control_name_wrt])

    def _setup_storage(self):
        if self._standalone_mode:
            self._configure_storage()

    def _configure_storage(self):
        gd = self._grid_data
        control_input_node_ptau = gd.node_ptau[gd.subset_node_indices['control_input']]

        # allocate the ODE parameter vector
        self.theta_size = 2 + self.p_size + self.u_size + self.up_size

        # allocate the integration parameter vector
        self.Z_size = self.x_size + self.theta_size

        start_Z = 0
        for state_name, options in self.state_options.items():
            state_size = np.prod(options['shape'], dtype=int)
            self._state_idxs_in_Z[state_name] = np.s_[start_Z: start_Z+state_size]
            start_Z += state_size

        start_Z = self.x_size + 2
        start_theta = 2
        for param_name, options in self.parameter_options.items():
            param_size = np.prod(options['shape'], dtype=int)
            self._parameter_idxs_in_Z[param_name] = np.s_[start_Z: start_Z+param_size]
            self._parameter_idxs_in_theta[param_name] = np.s_[start_theta: start_theta+param_size]
            start_Z += param_size
            start_theta += param_size

        start_Z = self.x_size + 2 + self.p_size
        start_theta = 2 + self.p_size
        start_y = 0
        for control_name, options in self.control_options.items():
            control_size = np.prod(options['shape'], dtype=int)
            control_param_shape = (len(control_input_node_ptau),) + options['shape']
            control_param_size = np.prod(control_param_shape, dtype=int)
            self._control_idxs_in_Z[control_name] = np.s_[start_Z:start_Z+control_param_size]
            self._control_idxs_in_theta[control_name] = np.s_[start_theta:start_theta+control_param_size]
            self._control_idxs_in_y[control_name] = np.s_[start_y:start_y+control_size]
            start_y += control_size
            self._control_rate_idxs_in_y[control_name] = np.s_[start_y:start_y+control_size]
            start_y += control_size
            self._control_rate2_idxs_in_y[control_name] = np.s_[start_y:start_y+control_size]
            start_y += control_size
            start_Z += control_param_size
            start_theta += control_param_size

        start_Z = self.x_size + 2 + self.p_size + self.u_size
        start_theta = 2 + self.p_size + self.u_size
        for name, options in self.polynomial_control_options.items():
            control_size = np.prod(options['shape'], dtype=int)
            num_input_nodes = options['order'] + 1
            control_param_shape = (num_input_nodes,) + options['shape']
            control_param_size = np.prod(control_param_shape, dtype=int)
            self._polynomial_control_idxs_in_Z[name] = np.s_[start_Z:start_Z+control_param_size]
            self._polynomial_control_idxs_in_theta[name] = np.s_[start_theta:start_theta+control_param_size]
            self._polynomial_control_idxs_in_y[name] = np.s_[start_y:start_y+control_size]
            start_y += control_size
            self._polynomial_control_rate_idxs_in_y[name] = np.s_[start_y:start_y+control_size]
            start_y += control_size
            self._polynomial_control_rate2_idxs_in_y[name] = np.s_[start_y:start_y+control_size]
            start_y += control_size
            start_Z += control_param_size
            start_theta += control_param_size

        for output_name, options in self._filtered_timeseries_outputs.items():
            size = np.prod(options['shape'], dtype=int)
            self._timeseries_idxs_in_y[output_name] = np.s_[start_y:start_y+size]
            start_y += size
        self.y_size = start_y

        self._allocate_storage()

    def setup(self):
        """
        Add the necessary I/O and storage for the RKIntegrationComp.
        """
        gd = self._grid_data

        # Indices to map the rows to output rows
        N = gd.subset_num_nodes_per_segment['all'][0] if self.options['times_per_seg'] is None else self.options['times_per_seg']
        temp = np.zeros((gd.num_segments, N+1))
        temp[:, 0] = 1
        temp[:, -1] = 1
        self._output_src_idxs = np.where(temp.ravel() == 1)[0]

        self._num_output_rows = gd.num_segments * 2
        self._num_rows = gd.num_segments * (N + 1)

        self._totals_of_names = []
        self._totals_wrt_names = []

        self._setup_subprob()
        self._setup_time()
        self._setup_parameters()
        self._setup_controls()
        self._setup_states()
        self._setup_timeseries()
        self._setup_storage()

    # def _reset_derivs(self):
    #     """
    #     Reset the value of total derivatives prior to propagation.
    #     """
    #     N = self.options['num_steps_per_segment']
    #     num_x = self.x_size
    #     num_theta = self.theta_size
    #
    #     # Let Z be [x0.ravel() t0 tp p.ravel() u.ravel()]
    #     self._dx_dZ[...] = 0.0  # np.zeros((num_x, num_z), dtype=self._DTYPE)
    #     self._dx_dZ[0, :, :num_x] = np.eye(num_x, dtype=self._DTYPE)
    #     self._dt_dZ[...] = 0.0  # np.zeros((1, num_z), dtype=self._DTYPE)
    #     self._dt_dZ[0, 0, num_x] = 1.0
    #     self._dh_dZ[...] = 0.0  # np.zeros((1, num_z), dtype=self._DTYPE)
    #     self._dh_dZ[:, 0, num_x+1] = 1.0 / N
    #     self._dTi_dZ[...] = 0.0  # np.zeros((1, num_z), dtype=self._DTYPE)
    #     self._dXi_dZ[...] = 0.0  # np.zeros((num_x, num_z), dtype=self._DTYPE)
    #     self._dkq_dZ[...] = 0.0  # np.zeros((num_stages, num_x, num_z), dtype=self._DTYPE)
    #     self._dtheta_dZ[...] = 0.0  # np.zeros((num_theta, num_z), dtype=self._DTYPE)
    #     self._dtheta_dZ[:, num_x:] = np.eye(num_theta, dtype=self._DTYPE)

    # def _initialize_segment(self, row, inputs=None, derivs=False):
    #     """
    #     Set the derivatives at the current row to those of the previous row.
    #
    #     This is used to continue the value of derivatives over a segment boundary.
    #     """
    #     if row == 0:
    #         # start x, t, and h
    #         for state_name in self.state_options:
    #             i_name = self._state_input_names[state_name]
    #             self._x[0, self.state_idxs[state_name], 0] = inputs[i_name].ravel()
    #         self._t[0, 0] = inputs['t_initial'].copy()
    #
    #         if derivs:
    #             self._reset_derivs()
    #     else:
    #         # copy last x, t, h
    #         self._x[row, ...] = self._x[row-1, ...]
    #         self._t[row, ...] = self._t[row-1, ...]
    #
    #         if derivs:
    #             # The 3 arrays of propagated derivatives need to copy over previous values
    #             self._dx_dZ[row, ...] = self._dx_dZ[row-1, ...]
    #             self._dt_dZ[row, ...] = self._dt_dZ[row-1, ...]
    #             self._dh_dZ[row, ...] = self._dh_dZ[row-1, ...]
    #
    #             # Derivatives of the internal calls are just reset
    #             self._dTi_dZ[...] = 0.0  # np.zeros((1, num_z), dtype=self._DTYPE)
    #             self._dXi_dZ[...] = 0.0  # np.zeros((num_x, num_z), dtype=self._DTYPE)
    #             self._dkq_dZ[...] = 0.0  # np.zeros((num_stages, num_x, num_z), dtype=self._DTYPE)
    #
    #             # dtheta_dZ remains constant across segments

    def _subprob_run_model(self, x, t, theta, linearize=True):
        """
        Set inputs to the model given x, t, and theta, evaluate the model, and linearize if requested.

        Parameters
        ----------
        x : np.ndarray
            A flattened, contiguous vector of the state values.
        t : float
            The current time of the integration.
        theta : np.ndarray
            A flattened, contiguous vector of the ODE parameter values.
        linearize : bool
            If True, linearize the model after calling run_model.

        Returns
        -------

        """
        subprob = self._eval_subprob

        # transcribe time
        subprob.set_val('t', t, units=self.time_options['units'])
        subprob.set_val('t_initial', theta[0], units=self.time_options['units'])
        subprob.set_val('t_duration', theta[1], units=self.time_options['units'])

        # transcribe states
        for name in self.state_options:
            input_name = self._state_input_names[name]
            subprob.set_val(input_name, x[self.state_idxs[name]])

        # transcribe parameters
        for name in self.parameter_options:
            input_name = self._param_input_names[name]
            subprob.set_val(input_name, theta[self._parameter_idxs_in_theta[name]])

        # transcribe controls
        for name in self.control_options:
            input_name = self._control_input_names[name]
            subprob.set_val(input_name, theta[self._control_idxs_in_theta[name]])

        for name in self.polynomial_control_options:
            input_name = self._polynomial_control_input_names[name]
            subprob.set_val(input_name, theta[self._polynomial_control_idxs_in_theta[name]])

        # Re-run in case the inputs have changed.
        subprob.run_model()

        if linearize:
            subprob.model._linearize(None)

    def eval_f(self, x, t, theta):
        """
        Evaluate the ODE which provides the state rates for integration.

        Parameters
        ----------
        x : np.ndarray
            A flattened, contiguous vector of the state values.
        t : float
            The current time of the integration.
        theta : np.ndarray
            A flattened, contiguous vector of the ODE parameter values.

        Returns
        -------
        f : np.ndarray
            A flattened, contiguous vector of the state rates.
        """
        self._subprob_run_model(x, t, theta, linearize=False, subprob=self._eval_subprob)

        f = np.zeros((self.x_size,))

        # pack the resulting array
        for name in self.state_options:
            f[self.state_idxs[name]] = self._eval_subprob.get_val(f'state_rate_collector.state_rates:{name}_rate').ravel()

        return f

    def eval_ode(self, x, t, theta, eval_solution=True, eval_derivs=True):
        """
        Evaluate the derivative of the ODE output rates wrt the inputs.

        Note that the control parameterization `u` undergoes an interpolation to provide the
        control values at any given time.  The ODE is then a function of these interpolated control
        values, we'll call them `u_hat`.  Technically, the derivatives wrt to `u` need to be chained
        together, but in this implementation the interpolation is part of the execution of the ODE
        and the chained derivatives are captured correctly there.

        Parameters
        ----------
        x : np.ndarray
            A flattened, contiguous vector of the state values.
        t : float
            The current time of the integration.
        theta : np.ndarray
            A flattened, contiguous vector of the ODE parameter values.
        eval_solution : bool
            If True, return the output of

        Returns
        -------
        f : np.ndarray
            The outputs of the ODE state rates, or None if eval_solution is False.
        f_x : np.ndarray
            A matrix of the derivative of each element of the rates `f` wrt each value in `x`, or None
            if eval_derivs is False.
        f_t : np.ndarray
            A matrix of the derivatives of each element of the rates `f` wrt `time`, or None
            if eval_derivs is False.
        f_theta : np.ndarray
            A matrix of the derivatives of each element of the rates `f` wrt the parameters `theta`, or None
            if eval_derivs is False.
        """
        self._subprob_run_model(x, t, theta, linearize=False)

        # pack the resulting array
        if eval_solution:
            f = np.zeros((self.x_size,))
            for name in self.state_options:
                f[self.state_idxs[name]] = self._eval_subprob.get_val(
                    f'state_rate_collector.state_rates:{name}_rate').ravel()
        else:
            f = None

        if eval_derivs:
            f_t = np.zeros((self.x_size, 1))
            f_x = np.zeros((self.x_size, self.x_size))
            f_theta = np.zeros((self.x_size, self.theta_size))

            totals = self._eval_subprob.compute_totals(of=self._state_rate_of_names,
                                                       wrt=self._totals_wrt_names,
                                                       use_abs_names=False)

            for state_name in self.state_options:
                of_name = f'state_rate_collector.state_rates:{state_name}_rate'
                idxs = self.state_idxs[state_name]

                f_t[self.state_idxs[state_name]] = totals[of_name, 't']

                for state_name_wrt in self.state_options:
                    idxs_wrt = self.state_idxs[state_name_wrt]
                    px_px = totals[of_name, self._state_input_names[state_name_wrt]]
                    f_x[idxs, idxs_wrt] = px_px.ravel()

                f_theta[idxs, 0] = totals[of_name, 't_initial']
                f_theta[idxs, 1] = totals[of_name, 't_duration']

                for param_name_wrt in self.parameter_options:
                    idxs_wrt = self._parameter_idxs_in_theta[param_name_wrt]
                    px_pp = totals[of_name, self._param_input_names[param_name_wrt]]
                    f_theta[idxs, idxs_wrt] = px_pp.ravel()

                for control_name_wrt in self.control_options:
                    idxs_wrt = self._control_idxs_in_theta[control_name_wrt]
                    px_pu = totals[of_name, self._control_input_names[control_name_wrt]]
                    f_theta[idxs, idxs_wrt] = px_pu.ravel()

                for pc_name_wrt in self.polynomial_control_options:
                    idxs_wrt = self._polynomial_control_idxs_in_theta[pc_name_wrt]
                    px_ppc = totals[of_name, self._polynomial_control_input_names[pc_name_wrt]]
                    f_theta[idxs, idxs_wrt] = px_ppc.ravel()

        else:
            f_x = f_t = f_theta = None

        return f, f_x, f_t, f_theta

    def _f_augmented(self, t, y, theta, dtheta_dz):
        """
        The ODE-callable function where y is the augmented state vector, theta are the ODE parameters, and dtheta_dz
        are the sensitivities of the ODE parameters to the integration parameters.

        Parameters
        ----------
        t : float
            The current value of the integration variable.
        y : np.array
            The augmented state vector.
        theta : np.array
            The ODE parameter vector. The first two elements are t_initial and t_duration.
        dtheta_dz : np.array
            The sensitivities of the ODE parameters wrt the integration parameters. Since the ODE parameters are
            just the integration parameters with the first num_x columns removed, this is a matrix of shape
            (num_dtheta, num_z - num_x).

        Returns
        -------
        y_dot : np.array
            The rates associated with each state in the augmented state vector (primal and tangent states).
        """
        n_x = self.x_size
        n_theta = self.theta_size
        n_z = n_x + n_theta

        x = y[:n_x].reshape((1, n_x))
        td = theta[1]

        dx_dz = y[n_x:n_x + n_x * n_z].reshape((n_x, n_z))
        dt_dz = y[-n_z:].reshape((1, n_z))

        x_dot, f_x, f_t, f_theta = self.eval_ode(x, t, theta, eval_solution=True, eval_derivs=True)

        dh_dz = np.array([[0, 0, 1.0/td, 0]])
        dt_dz_dot = dh_dz

        dx_dz_dot = f_x @ dx_dz + f_t @ dt_dz + f_theta @ dtheta_dz + x_dot @ dt_dz_dot

        y_dot = np.concatenate((x_dot.ravel(),
                                dx_dz_dot.ravel(),
                                dt_dz_dot.ravel()))

        return y_dot

    def _f_primal(self, t, x, theta):
        """
        The ODE-callable function where y is the augmented state vector, theta are the ODE parameters, and dtheta_dz
        are the sensitivities of the ODE parameters to the integration parameters.

        Parameters
        ----------
        t : float
            The current value of the integration variable.
        y : np.array
            The augmented state vector.
        theta : np.array
            The ODE parameter vector. The first two elements are t_initial and t_duration.

        Returns
        -------
        y_dot : np.array
            The rates associated with each state in the augmented state vector (primal and tangent states).
        """
        x_dot, _, _, _ = self.eval_ode(x, t, theta, eval_solution=True, eval_derivs=False)

        return x_dot

    def _propagate(self, x_initial, theta, t_out=None, propagate_derivs=True):
        """
        Propagate the augmented state, y = [x, dx_dz, dt_dz].

        Parameters
        ----------
        x_initial : np.array
            Initial value of the primal state.
        theta : np.array
            Values of the parameters influencing the ODE output. The first two elements are t_initial and t_duration,
            followed by the control node values, followed by the polynomial control node values.
        t_out : np.array or None
            Values at which the output of the integration are requested.
        propagate_derivs : bool
            If True, propagate the derivatives of the states and of time w.r.t. the integration parameters vector, z.

        Returns
        -------
        x : np.array
            The values of the primal states at the nodes in the phase.
        dx_dz : np.array
            The sensitivities of the final states w.r.t. the integration parameters vector, z, or None if
            propagate_derivs is False.
        """
        method = self.options['method']
        first_step = self.options['first_step']
        max_step = self.options['max_step']
        atol = self.options['atol']
        rtol = self.options['rtol']
        times_per_seg = self.options['times_per_seg']
        gd = self._grid_data
        num_seg = gd.num_segments

        n_x = self.x_size
        n_theta = self.theta_size
        n_z = n_x + n_theta

        t_initial = theta[0]
        t_duration = theta[1]

        if times_per_seg is None:
            nnps = gd.subset_num_nodes_per_segment['all']
        else:
            nnps = [times_per_seg for i in range(num_seg)]

        nn = sum(nnps)

        t_eval_all_nodes = t_initial + 0.5 * (gd.node_ptau + 1) * t_duration

        x_out = np.zeros((nn, n_x))

        if propagate_derivs:
            dx_dz_0 = np.zeros((1, n_z))
            dx_dz_0[:, :n_x] = np.eye(n_x)

            dt_dz_0 = np.zeros((1, n_z))
            dt_dz_0[0, n_x] = 1

            dtheta_dz = np.zeros((n_theta, n_z))
            dtheta_dz[:, -n_theta:] = np.eye(n_theta)
            dx_dz_out = np.zeros((nn, n_x*n_z))

            y0 = np.concatenate((x_initial.ravel(), dx_dz_0.ravel(), dt_dz_0.ravel()))
        else:
            dx_dz_out = None
            y0 = x_initial.ravel()

        row_seg_i = 0

        for i in range(self._grid_data.num_segments):
            self._set_segment_index(i)

            t_eval_seg = t_eval_all_nodes[row_seg_i:row_seg_i + nnps[i]]
            t_span_seg = (t_eval_seg[0], t_eval_seg[-1])

            if propagate_derivs:
                # The augmented initial state vector
                sol = solve_ivp(self._f_augmented, t_span=t_span_seg, t_eval=t_eval_seg, y0=y0,
                                args=(theta, dtheta_dz), method=method, first_step=first_step, max_step=max_step,
                                atol=atol, rtol=rtol)
                dx_dz_out[row_seg_i:row_seg_i+nnps[i], :] = sol.y.T[:, n_x:n_x+n_x*n_z]
            else:
                sol = solve_ivp(self._f_primal, t_span=t_span_seg, t_eval=t_eval_seg, y0=y0, args=(theta,),
                                method=method, first_step=first_step, max_step=max_step, atol=atol, rtol=rtol)

            y0 = sol.y.T[-1, :]  # Set initial y for the next segment
            x_out[row_seg_i:row_seg_i+nnps[i], :] = sol.y.T[:, :n_x]  # Save solution to the output nodes
            row_seg_i += nnps[i]  # Increment node associated with the start of the next segment

        return x_out, dx_dz_out

    def compute(self, inputs, outputs):
        """
        Compute propagated state values.

        Parameters
        ----------
        inputs : `Vector`
            `Vector` containing inputs.
        outputs : `Vector`
            `Vector` containing outputs.
        """
        self._inputs_cache = inputs.asarray()

        # Extract the state values
        x0 = np.zeros((self.x_size,))
        theta = np.zeros((self.theta_size,))
        
        for state_name in self.state_options:
            state_initial_val = inputs[self._state_input_names[state_name]]
            x0[self.state_idxs[state_name]] = state_initial_val

        theta[0] = inputs['t_initial']
        theta[1] = inputs['t_duration']

        for param_name in self.parameter_options:
            param_val = inputs[self._param_input_names[param_name]]
            theta[self._parameter_idxs_in_theta[param_name]] = param_val

        for control_name in self.control_options:
            control_vals = inputs[self._control_input_names[control_name]]
            theta[self._control_idxs_in_theta[param_name]] = control_vals

        for pc_name in self.polynomial_control_options:
            pc_vals = inputs[self._control_input_names[pc_name]]
            theta[self._polynomial_control_idxs_in_theta[param_name]] = pc_vals

        x, dx_dz = self._propagate(x_initial=x0, theta=theta, propagate_derivs=True)

        # Propagate returns a dictionary keyed by segment index, containing

        print(x)
        print(dx_dz)

        # # Unpack the outputs
        # idxs = self._output_src_idxs
        # outputs['t_final'] = self._t[-1, ...]
        #
        # # Extract time
        # outputs['t'] = self._t[idxs, ...]
        # outputs['t_phase'] = self._t[idxs, ...] - inputs['t_initial']
        #
        # # Extract the state values
        # for state_name in self.state_options:
        #     of = self._state_output_names[state_name]
        #     outputs[of] = self._x[idxs, self.state_idxs[state_name]]
        #
        # # Extract the control values and rates
        # for control_name in self.control_options:
        #     oname = self._control_output_names[control_name]
        #     rate_name = self._control_rate_names[control_name]
        #     rate2_name = self._control_rate2_names[control_name]
        #     outputs[oname] = self._y[idxs, self._control_idxs_in_y[control_name]]
        #     outputs[rate_name] = self._y[idxs, self._control_rate_idxs_in_y[control_name]]
        #     outputs[rate2_name] = self._y[idxs, self._control_rate2_idxs_in_y[control_name]]
        #
        # # Extract the control values and rates
        # for control_name in self.polynomial_control_options:
        #     oname = self._polynomial_control_output_names[control_name]
        #     rate_name = self._polynomial_control_rate_names[control_name]
        #     rate2_name = self._polynomial_control_rate2_names[control_name]
        #     outputs[oname] = self._y[idxs, self._polynomial_control_idxs_in_y[control_name]]
        #     outputs[rate_name] = self._y[idxs, self._polynomial_control_rate_idxs_in_y[control_name]]
        #     outputs[rate2_name] = self._y[idxs, self._polynomial_control_rate2_idxs_in_y[control_name]]
        #
        # # Extract the timeseries outputs
        # for name in self._filtered_timeseries_outputs:
        #     oname = self._timeseries_output_names[name]
        #     outputs[oname] = self._y[idxs, self._timeseries_idxs_in_y[name]]

    def compute_partials(self, inputs, partials):
        """
        Compute derivatives of propagated states wrt the inputs.

        Parameters
        ----------
        inputs : Vector
            Unscaled, dimensional input variables read via inputs[key].
        partials : Jacobian
            Subjac components written to partials[output_name, input_name].
        """
        dt_dZ = self._dt_dZ
        dx_dZ = self._dx_dZ
        dy_dZ = self._dy_dZ

        if np.max(np.abs(self._inputs_cache - inputs.asarray())) > 1.0E-16:
            self._propagate_vectorized_derivs(inputs)

        idxs = self._output_src_idxs
        partials['t', 't_duration'] = dt_dZ[idxs, 0, self.x_size+1]
        partials['t_phase', 't_duration'] = dt_dZ[idxs, 0, self.x_size+1]

        for state_name in self.state_options:
            of = self._state_output_names[state_name]

            # Unpack the derivatives
            of_rows = self.state_idxs[state_name]

            partials[of, 't_initial'] = dx_dZ[idxs, of_rows, self.x_size]
            partials[of, 't_duration'] = dx_dZ[idxs, of_rows, self.x_size+1]

            for wrt_state_name in self.state_options:
                wrt = self._state_input_names[wrt_state_name]
                wrt_cols = self._state_idxs_in_Z[wrt_state_name]
                partials[of, wrt] = dx_dZ[idxs, of_rows, wrt_cols]

            for wrt_param_name in self.parameter_options:
                wrt = self._param_input_names[wrt_param_name]
                wrt_cols = self._parameter_idxs_in_Z[wrt_param_name]
                partials[of, wrt] = dx_dZ[idxs, of_rows, wrt_cols]

            for wrt_control_name in self.control_options:
                wrt = self._control_input_names[wrt_control_name]
                wrt_cols = self._control_idxs_in_Z[wrt_control_name]
                partials[of, wrt] = dx_dZ[idxs, of_rows, wrt_cols]

            for wrt_pc_name in self.polynomial_control_options:
                wrt = self._polynomial_control_input_names[wrt_pc_name]
                wrt_cols = self._polynomial_control_idxs_in_Z[wrt_pc_name]
                partials[of, wrt] = dx_dZ[idxs, of_rows, wrt_cols]

        for control_name in self.control_options:
            of = self._control_output_names[control_name]
            of_rate = self._control_rate_names[control_name]
            of_rate2 = self._control_rate2_names[control_name]

            # Unpack the derivatives
            of_rows = self._control_idxs_in_y[control_name]
            of_rate_rows = self._control_rate_idxs_in_y[control_name]
            of_rate2_rows = self._control_rate2_idxs_in_y[control_name]

            wrt_cols = self.x_size + 1
            partials[of_rate, 't_duration'] = dy_dZ[idxs, of_rate_rows, wrt_cols]
            partials[of_rate2, 't_duration'] = dy_dZ[idxs, of_rate2_rows, wrt_cols]

            for wrt_control_name in self.control_options:
                wrt = self._control_input_names[wrt_control_name]
                wrt_cols = self._control_idxs_in_Z[wrt_control_name]
                partials[of, wrt] = dy_dZ[idxs, of_rows, wrt_cols]
                partials[of_rate, wrt] = dy_dZ[idxs, of_rate_rows, wrt_cols]
                partials[of_rate2, wrt] = dy_dZ[idxs, of_rate2_rows, wrt_cols]

        for name in self.polynomial_control_options:
            of = self._polynomial_control_output_names[name]
            of_rate = self._polynomial_control_rate_names[name]
            of_rate2 = self._polynomial_control_rate2_names[name]

            # Unpack the derivatives
            of_rows = self._polynomial_control_idxs_in_y[name]
            of_rate_rows = self._polynomial_control_rate_idxs_in_y[name]
            of_rate2_rows = self._polynomial_control_rate2_idxs_in_y[name]

            wrt_cols = self.x_size + 1
            partials[of_rate, 't_duration'] = dy_dZ[idxs, of_rate_rows, wrt_cols]
            partials[of_rate2, 't_duration'] = dy_dZ[idxs, of_rate2_rows, wrt_cols]

            for wrt_control_name in self.polynomial_control_options:
                wrt = self._polynomial_control_input_names[wrt_control_name]
                wrt_cols = self._polynomial_control_idxs_in_Z[wrt_control_name]
                partials[of, wrt] = dy_dZ[idxs, of_rows, wrt_cols]
                partials[of_rate, wrt] = dy_dZ[idxs, of_rate_rows, wrt_cols]
                partials[of_rate2, wrt] = dy_dZ[idxs, of_rate2_rows, wrt_cols]

        for name in self._filtered_timeseries_outputs:
            of = self._timeseries_output_names[name]
            of_rows = self._timeseries_idxs_in_y[name]

            partials[of, 't_initial'] = dy_dZ[idxs, of_rows, self.x_size]
            partials[of, 't_duration'] = dy_dZ[idxs, of_rows, self.x_size+1]

            for wrt_state_name in self.state_options:
                wrt = self._state_input_names[wrt_state_name]
                wrt_cols = self._state_idxs_in_Z[wrt_state_name]
                partials[of, wrt] = dy_dZ[idxs, of_rows, wrt_cols]

            for wrt_param_name in self.parameter_options:
                wrt = self._param_input_names[wrt_param_name]
                wrt_cols = self._parameter_idxs_in_Z[wrt_param_name]
                partials[of, wrt] = dy_dZ[idxs, of_rows, wrt_cols]

            for wrt_control_name in self.control_options:
                wrt = self._control_input_names[wrt_control_name]
                wrt_cols = self._control_idxs_in_Z[wrt_control_name]
                partials[of, wrt] = dy_dZ[idxs, of_rows, wrt_cols]

            for wrt_pc_name in self.polynomial_control_options:
                wrt = self._polynomial_control_input_names[wrt_pc_name]
                wrt_cols = self._polynomial_control_idxs_in_Z[wrt_pc_name]
                partials[of, wrt] = dy_dZ[idxs, of_rows, wrt_cols]
